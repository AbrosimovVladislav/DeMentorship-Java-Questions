[На главную](../README.md)

# Lambda

+ [Что такое _
  «лямбда»_? Какова структура и особенности использования лямбда-выражения?](#Что-такое-_«лямбда»_?-Какова-структура-и-особенности-использования-лямбда-выражения?)

## Что такое _«лямбда»_? Какова структура и особенности использования лямбда-выражения?

__Лямбда__ представляет собой набор инструкций, которые можно выделить в отдельную переменную и
затем многократно вызвать в различных местах программы.

Основу лямбда-выражения составляет _лямбда-оператор_, который представляет стрелку `->`. Этот
оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения,
а правая, собственно, представляет тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в
функциональном интерфейсе. При этом важно, что функциональный интерфейс должен содержать только один
единственный метод без реализации.

```java
interface Operationable {

  int calculate(int x, int y);
}

  public static void main(String[] args) {
    Operationable operation = (x, y) -> x + y;
    int result = operation.calculate(10, 20);
    System.out.println(result); //30
  }
```

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов,
которые ранее применялись в Java.

+ _Отложенное выполнение (deferred execution) лямбда-выражения_- определяется один раз в одном месте
  программы, вызываются при необходимости, любое количество раз и в произвольном месте программы.

+ _Параметры лямбда-выражения_ должны соответствовать по типу параметрам метода функционального
  интерфейса:

```java
operation=(int x,int y)->x+y;
//При написании самого лямбда-выражения тип параметров разрешается не указывать:
    (x,y)->x+y;
//Если метод не принимает никаких параметров, то пишутся пустые скобки, например,
    ()->30+20;
//Если метод принимает только один параметр, то скобки можно опустить:
    n->n*n;
```

+ _Конечные лямбда-выражения_ не обязаны возвращать какое-либо значение.

```java
interface Printable {

  void print(String s);
}

  public static void main(String[] args) {
    Printable printer = s -> System.out.println(s);
    printer.print("Hello, world");
  }
```

+ _Блочные лямбда-выражения_ обрамляются фигурными скобками. В блочных лямбда-выражениях можно
  использовать внутренние вложенные блоки, циклы, конструкции `if`, `switch`, создавать переменные и
  т.д. Если блочное лямбда-выражение должно возвращать значение, то явным образом применяется
  оператор `return`:

```java
Operationable operation=(int x,int y)->{
    if(y==0){
    return 0;
    }
    else{
    return x/y;
    }
    };
```

+ _Передача лямбда-выражения в качестве параметра метода_:

```java
interface Condition {

  boolean isAppropriate(int n);
}

  private static int sum(int[] numbers, Condition condition) {
    int result = 0;
    for (int i : numbers) {
      if (condition.isAppropriate(i)) {
        result += i;
      }
    }
    return result;
  }

  public static void main(String[] args) {
    System.out.println(sum(new int[]{0, 1, 0, 3, 0, 5, 0, 7, 0, 9}, (n) -> n != 0));
  } 
```

## К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. Можно ссылаться на:

+ неизменяемые (_effectively final_ - не обязательно помеченные как `final`) локальные переменные;
+ поля класса;
+ статические переменные.

К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.

## Как отсортировать список строк с помощью лямбда-выражения?
```java
public static List<String> sort(List<String> list){
    Collections.sort(list, (a, b) -> a.compareTo(b));
    return list;
}
```

## Что такое «ссылка на метод»?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `имя_класса::имя_статического_метода` для статического метода;
+ `объект_класса::имя_метода` для метода экземпляра;
+ `название_класса::new` для конструктора.

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.

## Какие виды ссылок на методы вы знаете?
+ на статический метод;
+ на метод экземпляра;
+ на конструкторе.

## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.

